"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.readJSON = exports.createMetadata = void 0;
const js_1 = require("@metaplex/js");
const web3_js_1 = require("@solana/web3.js");
const fs_1 = __importDefault(require("fs"));
const util_1 = require("./util");
function createMetadata(connection, wallet, editionMint, 
//must cleanly divide 100
//max 5 (metaplex's constraint)
totalCreatorsN = 5, 
//starts from 1, not 0
ourCreatorN = 1, 
//leave our creator unverified for negatives testing
leaveUnverified = false, 
//skips our creator entirely for negatives testing
skipEntirely = false) {
    return __awaiter(this, void 0, void 0, function* () {
        const metadataData = parseMetadata(readJSON('./tests/artifacts/testMetadata.json'));
        //we insert as many creators as we'd like for testing, including our target creator
        for (let i = 0; i < totalCreatorsN; i++) {
            metadataData.creators.push(new js_1.programs.metadata.Creator({
                address: !skipEntirely && i === ourCreatorN - 1
                    ? wallet.publicKey.toBase58()
                    : web3_js_1.Keypair.generate().publicKey.toBase58(),
                verified: !leaveUnverified && i === ourCreatorN - 1,
                share: 100 / totalCreatorsN,
            }));
        }
        yield js_1.actions.createMetadata({
            connection,
            wallet,
            editionMint,
            metadataData,
        });
        //necessary for metadata to propagate, even on localnet
        yield (0, util_1.pause)(2000);
        //verify metadata propagated successfully and is available
        const metadata = yield js_1.programs.metadata.Metadata.getPDA(editionMint);
        const metadataAcc = yield js_1.programs.metadata.Metadata.load(connection, metadata);
        console.log(`metadata at ${metadata.toBase58()} ok`);
        return metadata;
    });
}
exports.createMetadata = createMetadata;
function readJSON(path) {
    return JSON.parse(fs_1.default.readFileSync(path, 'utf-8'));
}
exports.readJSON = readJSON;
function parseMetadata(jsonMetadata) {
    return new js_1.programs.metadata.MetadataDataData({
        name: jsonMetadata.name,
        symbol: jsonMetadata.symbol,
        uri: jsonMetadata.uri,
        sellerFeeBasisPoints: jsonMetadata.sellerFeeBasisPoints,
        creators: jsonMetadata.creators.map((c) => new js_1.programs.metadata.Creator({
            address: c.address,
            verified: c.verified,
            share: c.share,
        })),
    });
}
